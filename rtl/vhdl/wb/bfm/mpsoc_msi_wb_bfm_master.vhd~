-- Converted from mpsoc_msi_wb_bfm_master.v
-- by verilog2vhdl - QueenField

--//////////////////////////////////////////////////////////////////////////////
--                                            __ _      _     _               //
--                                           / _(_)    | |   | |              //
--                __ _ _   _  ___  ___ _ __ | |_ _  ___| | __| |              //
--               / _` | | | |/ _ \/ _ \ '_ \|  _| |/ _ \ |/ _` |              //
--              | (_| | |_| |  __/  __/ | | | | | |  __/ | (_| |              //
--               \__, |\__,_|\___|\___|_| |_|_| |_|\___|_|\__,_|              //
--                  | |                                                       //
--                  |_|                                                       //
--                                                                            //
--                                                                            //
--              MPSoC-RISCV CPU                                               //
--              Master Slave Interface                                        //
--              Wishbone Bus Interface                                        //
--                                                                            //
--//////////////////////////////////////////////////////////////////////////////

-- Copyright (c) 2018-2019 by the author(s)
-- *
-- * Permission is hereby granted, free of charge, to any person obtaining a copy
-- * of this software and associated documentation files (the "Software"), to deal
-- * in the Software without restriction, including without limitation the rights
-- * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
-- * copies of the Software, and to permit persons to whom the Software is
-- * furnished to do so, subject to the following conditions:
-- *
-- * The above copyright notice and this permission notice shall be included in
-- * all copies or substantial portions of the Software.
-- *
-- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
-- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
-- * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
-- * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
-- * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
-- * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
-- * THE SOFTWARE.
-- *
-- * =============================================================================
-- * Author(s):
-- *   Francisco Javier Reina Campo <frareicam@gmail.com>
-- */

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.math_real.all;

use work.mpsoc_msi_wb_pkg.all;

entity mpsoc_msi_wb_bfm_master is
  generic (
    AW : integer := 32;
    DW : integer := 32;
    TP : integer := 0;

    MAX_BURST_LEN : integer := 32;
    MAX_WAIT_STATES : integer := 8;

    VERBOSE : integer := 0
  );
  port (
    wb_clk_i : in std_logic;
    wb_rst_i : in std_logic;
    wb_adr_o : out std_logic_vector(AW-1 downto 0);
    wb_dat_o : out std_logic_vector(DW-1 downto 0);
    wb_sel_o : out std_logic_vector(DW/8-1 downto 0);
    wb_we_o : out std_logic;
    wb_cyc_o : out std_logic;
    wb_stb_o : out std_logic;
    wb_cti_o : out std_logic_vector(2 downto 0);
    wb_bte_o : out std_logic_vector(1 downto 0);
    wb_dat_i : in std_logic_vector(DW-1 downto 0);
    wb_ack_i : in std_logic;
    wb_err_i : in std_logic 
    wb_rty_i : in std_logic
  );
end mpsoc_msi_wb_bfm_master;

architecture RTL of mpsoc_msi_wb_bfm_master is
  --////////////////////////////////////////////////////////////////
  --
  -- Constants
  --
  constant BUFFER_WIDTH : integer := integer(log2(real(MAX_BURST_LEN)));
  constant ADR_LSB : integer := integer(log2(real(DW/8)));

  --////////////////////////////////////////////////////////////////
  --
  -- Constants
  --
  type M_MAX_BURST_LEN_DW is array (MAX_BURST_LEN-1 downto 0) of std_logic_vector(DW-1 downto 0);

  --////////////////////////////////////////////////////////////////
  --
  -- Variables
  --
  signal addr : std_logic_vector(AW-1 downto 0);
  signal index : std_logic_vector(31 downto 0);
  signal data : std_logic_vector(DW-1 downto 0);
  signal mask : std_logic_vector(DW/8-1 downto 0);
  signal op : std_logic;

  signal cycle_type : std_logic_vector(2 downto 0);
  signal burst_type : std_logic_vector(2 downto 0);
  signal burst_length : std_logic_vector(31 downto 0);
  signal buffer_addr_tmp : std_logic_vector(AW-1 downto 0);
  signal buffer_addr : std_logic_vector(BUFFER_WIDTH-1 downto 0);

  signal write_data : M_MAX_BURST_LEN_DW;
  signal buffer_data : M_MAX_BURST_LEN_DW;

  signal wait_states : std_logic_vector(integer(log2(real(MAX_WAIT_STATES))) downto 0);
  signal wait_states_cnt : std_logic_vector(integer(log2(real(MAX_WAIT_STATES))) downto 0);

  signal word : integer;

  --////////////////////////////////////////////////////////////////
  --
  -- Tasks
  --
  procedure reset (
  ) is
  begin
    wb_adr_o <= concatenate(AW, '0');
    wb_dat_o <= concatenate(DW, '0');
    wb_sel_o <= concatenate(DW/8, '0');
    wb_we_o <= '0';
    wb_cyc_o <= '0';
    wb_stb_o <= '0';
    wb_cti_o <= "000";
    wb_bte_o <= "00";
  end reset;

  procedure write (
    addr_i : in std_logic_vector(AW-1 downto 0);
    data_i : in std_logic_vector(DW-1 downto 0);
    mask_i : in std_logic_vector(DW/8-1 downto 0);

    err_o : out std_logic

  ) is
  begin
    addr <= addr_i;
    data <= data_i;
    mask <= mask_i;
    cycle_type <= CTI_CLASSIC;
    op <= WRITE;

    init;
    wait until rising_edge(wb_clk_i);
    next;
    err_o <= wb_err_i;
    insert_wait_states;
  end write;

  procedure write_burst (
    base_addr : in std_logic_vector(AW-1 downto 0);
    addr_i : in std_logic_vector(AW-1 downto 0);
    mask_i : in std_logic_vector(DW/8-1 downto 0);
    cycle_type_i : in std_logic_vector(2 downto 0);
    burst_type_i : in std_logic_vector(2 downto 0);
    burst_length_i : in std_logic_vector(31 downto 0);
    err_o : out std_logic
  ) is
  begin

    addr <= addr_i;
    buffer_addr_tmp <= addr_i-base_addr;
    buffer_addr <= buffer_addr_tmp(ADR_LSB+BUFFER_WIDTH-1 downto ADR_LSB);
    mask <= mask_i;
    op <= WRITE;
    burst_length <= burst_length_i;
    cycle_type <= cycle_type_i;
    burst_type <= burst_type_i;
    index <= 0;
    err_o <= 0;

    init;

    while (index < burst_length) loop
      buffer_data(buffer_addr) <= write_data(index);
      data <= write_data(index);

      if (VERBOSE > 2) then
        report "    %t: Write Data %h written to buffer at address %h at iteration %0d", timing(), write_data(index), buffer_addr, index);
        report "    %t: Write Data %h written to memory at address %h at iteration %0d", timing(), write_data(index), addr, index);
      elsif (VERBOSE > 1) then
        report "    %t: Write Data %h written to memory at address %h at iteration %0d", timing(), write_data(index), addr, index);
      end if;

      next;
      addr <= (null)(addr, cycle_type, burst_type, DW);
      buffer_addr_tmp <= addr-base_addr;
      buffer_addr <= buffer_addr_tmp(ADR_LSB+BUFFER_WIDTH-1 downto ADR_LSB);
      index <= index+1;
    end loop;

    clear_write_data;

    insert_wait_states;
  end write_burst;

  procedure read_burst_comp (
    base_addr : in std_logic_vector(AW-1 downto 0);
    addr_i : in std_logic_vector(AW-1 downto 0);
    mask_i : in std_logic_vector(DW/8-1 downto 0);
    cycle_type_i : in std_logic_vector(2 downto 0);
    burst_type_i : in std_logic_vector(1 downto 0);
    burst_length_i : in std_logic_vector(31 downto 0);
    err_o : out std_logic
  ) is
  begin

    addr <= addr_i;
    buffer_addr_tmp <= addr_i-base_addr;
    buffer_addr <= buffer_addr_tmp(ADR_LSB+BUFFER_WIDTH-1 downto ADR_LSB);
    mask <= mask_i;
    op <= READ;
    cycle_type <= cycle_type_i;
    burst_type <= burst_type_i;
    burst_length <= burst_length_i;
    index <= 0;
    err_o <= 0;

    init;

    while (index < burst_length) loop
      next;
      (null)(addr, data, index);
      addr <= (null)(addr, cycle_type, burst_type, DW);
      buffer_addr_tmp <= addr-base_addr;
      buffer_addr <= buffer_addr_tmp(ADR_LSB+BUFFER_WIDTH-1 downto ADR_LSB);
      index <= index+1;
    end loop;

    insert_wait_states;
  end read_burst_comp;

  procedure data_compare (
    addr : in std_logic_vector(AW-1 downto 0);
    read_data : in std_logic_vector(DW-1 downto 0);
    iteration : in std_logic_vector(31 downto 0)

  ) is
  begin

    if (VERBOSE > 2) then
      report "    %t: Comparing Read Data for iteration %0d at address: %h", timing(), iteration, addr);
      report "    %t: Read Data: %h, buffer data: %h, buffer address: %h", timing(), read_data, buffer_data(buffer_addr), buffer_addr);
    elsif (VERBOSE > 1) then
      report "    Comparing Read Data for iteration %0d at address: %h", iteration, addr);
    end if;

    if (buffer_data(buffer_addr) /= read_data) then
      report "Read data mismatch during iteration %0d at address %h", iteration, addr);
      report "Expected %h", buffer_data(buffer_addr));
      report "Got      %h", read_data);
      finish after 3;
    elsif (VERBOSE > 1) then
      report "    Data Matched";
    end if;
  end data_compare;

  procedure insert_wait_states (
  ) is
  begin

    wb_cyc_o <= '0' after TP;
    wb_stb_o <= '0' after TP;
    wb_we_o <= '0' after TP;
    wb_cti_o <= "000" after TP;
    wb_bte_o <= "00" after TP;
    wb_sel_o <= concatenate(DW/8, '0') after TP;
    wb_adr_o <= concatenate(AW, '0') after TP;
    wb_dat_o <= concatenate(DW, '0') after TP;

    for wait_states_cnt in 0 to wait_states - 1 loop
      wait until rising_edge(wb_clk_i);
    end loop;
  end insert_wait_states;

  procedure clear_write_data (
  ) is
  begin
    for word in 0 to MAX_BURST_LEN-1 - 1 loop
      write_data(word) <= concatenate(DW, 'x');
    end loop;
  end clear_write_data;

  procedure clear_buffer_data (
  ) is
  begin
    for word in 0 to MAX_BURST_LEN-1 - 1 loop
      buffer_data(word) <= X"xxxxxxxx";
    end loop;
  end clear_buffer_data;

  --Low level tasks
  procedure init (
  ) is
  begin
    if (wb_rst_i /= '0') then
      wait until falling_edge(wb_rst_i);
      wait until rising_edge(wb_clk_i);
    end if;

    wb_sel_o <= mask after TP;
    wb_we_o <= op after TP;
    wb_cyc_o <= '1' after TP;

    if (cycle_type = CTI_CLASSIC) then
      if (VERBOSE > 1) then
        report "INIT: Classic Cycle";
      end if;
      wb_cti_o <= "000" after TP;
      wb_bte_o <= "00" after TP;
    elsif (index = burst_length-1) then
      if (VERBOSE > 1) then
        report "INIT: Burst - last cycle";
      end if;
      wb_cti_o <= "111" after TP;
      wb_bte_o <= "00" after TP;
    elsif (cycle_type = CTI_CONST_BURST) then
      if (VERBOSE > 1) then
        report "INIT: Const Burst cycle";
      end if;
      wb_cti_o <= "001" after TP;
      wb_bte_o <= "00" after TP;
    elsif (VERBOSE > 1) then
      report "INIT: Incr Burst cycle";
    wb_cti_o <= "010" after TP;
    wb_bte_o <= burst_type(1 downto 0) after TP;
    end if;
  end init;

  procedure next (
  ) is
  begin
    wb_adr_o <= addr after TP;
    wb_dat_o <= addr after TP;    --(op == WRITE) ? data : {DW{1'b0}};
    wb_stb_o <= addr after TP;    -- 1'b1; //FIXME: Add wait states

    if ((index = burst_length-1) and (cycle_type /= CTI_CLASSIC)) then
      wb_cti_o <= "111" after TP;

    end if;
    wait until rising_edge(wb_clk_i);
    while (wb_ack_i /= '1') loop
      wait until rising_edge(wb_clk_i);
    end loop;
    data <= wb_dat_i;
  end next;

begin
  index <= 0;
  data <= concatenate(DW, '0');
end RTL;
